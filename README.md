# Задание 3

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

Сервис написан с использованием [bem-components](https://ru.bem.info/platform/libs/bem-components/5.0.0/).

Работа избранного в оффлайне реализована с помощью технологии [Service Worker](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers).

Для поиска изображений используется [API сервиса Giphy](https://github.com/Giphy/GiphyAPI).

В браузерах, не поддерживающих сервис-воркеры, приложение так же должно корректно работать, 
за исключением возможности работы в оффлайне.

## Структура проекта

  * `gifs.html` – точка входа
  * `assets` – статические файлы проекта
  * `vendor` –  статические файлы внешних библиотек
  * `service-worker.js` – скрипт сервис-воркера

Открывать `gifs.html` нужно с помощью локального веб-сервера – не как файл. 
Это можно сделать с помощью встроенного в WebStorm/Idea веб-сервера, с помощью простого сервера
из состава PHP или Python. Можно воспользоваться и любым другим способом.

## Ход решения
Первым делом я просто запустил приложение, проверил сообщения в консоли и попробовал офлайн-режим. В консоли было сообщение о том, что сервис воркер зарегистрирован, офлайн-режим не работал, кеш был пуст и туда ничего не сохранялось (смотрел это во вкладке Application). Тогда я проверил расположение файла `service-worker.js` в проекте. Оказалось, что он лежал в папке `assets`, а это значит, что под контролем сервис воркера может быть только содержимое этой папки, потому что максимальная видимость сервис воркера это его расположение. Чтобы расширить видимость на все остальные файлы, я переместил `service-worker.js` в корневую директорию приложения и поменял путь к нему в функции `register()`.

Затем еще раз проверил консоль. В ней было сообщение о том, что сервис воркер не удалось зарегистрировать и, что не получилось получить скрипт `kv-keeper.js` со ссылкой на девятую строку `service-worker.js`. Проверив эту строку, я удалил лишнюю точку в аргументе функции `importScripts()`.

Регистрация сервис воркера проходила успешно, но офлайн-режим по-прежнему не работал: файл `gifs.html` не кешировался. Тогда я посмотрел на обработку события `fetch`, в которой для каждого запрошенного ресурса выполнялась проверка с помощью функции `needStoreForOffline` на соответствие некоторым, нужным для сохранения в кеш, требованиям. Оказалось, что в кеш добавлялись только директории `assets` и `vendor` и файл `jquery.min.js`. Я разрешил файл `gifs.html`, добавив еще одну проверку. Офлайн-режим заработал, гифки, сохраненные в избранное грузились.

Также в обработке `fetch` я заметил, что ресурсы всегда грузятся из кеша, потому что функция `needStoreForOffline()` для всех файлов приложения возвращает *true*. Поэтому я убрал эту проверку и оставил только вызов функции `fetchWithFallbackToCache()`, которая пытается скачать ресурс, а при неудаче берет его из кеша. Так как функция `fetchAndPutToCache()` больше не вызывалась, я осуществил добавление всех файлов приложения в кеш в обработчике события `install`. Благодаря этому появилась возможность переключения в офлайн-режим после первого же запроса.

Изучив код, обнаружил, что для сообщения `'favorite:remove'`, нет обработчика и гифки, которые удаляются из избранного, не удаляются из кеша. Добавил обработчик сообщения `'favorite:remove'`, в котором удаленные гифки, удаляются из кеша.

## Ответы
**Вопрос №1: зачем нужен этот вызов?**
```javascript
.then(() => self.skipWaiting())
```

`skipWaiting()` позволяет новому сервис воркеру пропустить стадию ожидания, в которой он ждет, пока закроются все страницы, на которых работает старый сервис воркер, и сразу перейти в стадию активации.

**Вопрос №2: зачем нужен этот вызов?**
```javascript
self.clients.claim();
```
`clients.claim()` активирует новый сервис воркер на открытых страницах без их перезагрузки.

**Вопрос №3: для всех ли случаев подойдёт такое построение ключа?**
```javascript
const cacheKey = url.origin + url.pathname;
```

В функции `needStoreForOffline()` cacheKey проверяется на содержание в нем некоторых подстрок. Эти подстроки могут содержаться в url ресурсов, которые сохранять для офлайна не нужно, но они сохранятся. `Cache.match()` возвращает первый совпадающий ресурс, а url может содержать некоторые параметры после `?`. Здесь это не учитывается.

**Вопрос №4: зачем нужна эта цепочка вызовов?**
```javascript
return Promise.all(
    names.filter(name => name !== CACHE_VERSION)
        .map(name => {
            console.log('[ServiceWorker] Deleting obsolete cache:', name);
            return caches.delete(name);
        })
);
```
В ней удаляется весь кеш, версия которого не равна `CACHE_VERSION`, чтобы освободить место, занимаемое на диске.

**Вопрос №5: для чего нужно клонирование?**
```javascript
cache.put(cacheKey, response.clone());
```
`Response` может быть прочитан только один раз, поэтому в кеше сохраняется его клон, а оригинальный `response` отправляется браузеру. Таким образом каждый `response` читается один раз.
